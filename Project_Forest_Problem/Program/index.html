<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html lang="ja">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta http-equiv="Content-Style-Type" content="text/css">
<meta http-equiv="Content-Script-Type" content="text/javascript">
<meta name="keywords" content="Aoki,Atsushi,Smalltalk,Smalltalker,Program,Programmer,Object,Oriented,Programming">
<meta name="description" content="ソフトウェア工学IIの小テスト">
<meta name="author" content="AOKI Atsushi">
<link rev="made" href="index.html">
<link rel="index" href="index.html">
<style type="text/css">
<!--
body {
  background-color : #ffffff;
  margin : 20px;
  padding : 10px;
  font-family : serif;
  font-size : 10pt;
}
a {
  text-decoration : underline;
  color : #000000;
}
a:link {
  background-color : #ffddbb;
}
a:visited {
  background-color : #ccffcc;
}
a:hover {
  background-color : #dddddd;
}
a:active {
  background-color : #dddddd;
}
div.belt {
  background-color : #eeeeee;
  padding : 0px 4px;
}
div.belt-yellow {
  background-color : #ffffcc;
  padding : 0px 4px;
}
div.belt-blue {
  background-color : #ddeeff;
  padding : 0px 4px;
}
div.right-small {
  text-align : right;
  font-size : 8pt;
}
img.border {
  border-width : 1px;
  border-color : #000000;
  vertical-align : middle;
}
img.borderless {
  border-width : 0px;
  vertical-align : middle;
}
p.belt {
  background-color : #ffeedd;
  padding : 4px 8px;
}
p.belt-blue {
  background-color : #ddeeff;
  padding : 4px 8px;
}
pre.belt {
  background-color : #ddeeff;
  padding : 4px 8px;
}
pre.belt-yellow {
  background-color : #ffffcc;
  padding : 4px 8px;
}
table {
  border-style : solid;
  border-width : 0px;
  border-color : #000000;
  font-family : serif;
  font-size : 10pt;
}
table.profile {
  border-style : solid;
  border-width : 0px;
  border-color : #000000;
  font-family : serif;
  font-size : 10pt;
  margin-top : 8px;
  margin-left : 8px;
  margin-right : 8px;
  margin-bottom : 8px;
}
table.belt {
  border-style : solid;
  border-width : 0px;
  border-color : #000000;
  background-color : #ffeedd;
  padding : 0px 0px;
  width : 100%;
}
table.content {
  border-style : solid;
  border-width : 0px;
  border-color : #000000;
  padding : 2px 4px;
}
table.font-fixed {
  border-style : solid;
  border-width : 0px;
  border-color : #000000;
  padding : 2px 4px;
  font-family : monospace;
}
table.nest {
  border-style : solid;
  border-width : 0px;
  border-color : #000000;
  padding : 0px 0px;
}
td {
  padding : 0px 0px;
  vertical-align : middle;
}
td.center {
  text-align : center;
}
td.center-half {
  text-align : center;
  width : 50%;
  font-size : 8pt;
}
td.center-small {
  text-align : center;
  font-size : 8pt;
  padding : 0px 4px;
}
td.center-small-nopadding {
  text-align : center;
  font-size : 8pt;
  padding : 0px 0px;
}
td.center-white {
  text-align : center;
  background-color : #ffffff;
}
td.center-small-white {
  text-align : center;
  font-size : 8pt;
  background-color : #ffffff;
}
td.center-border1 {
  text-align : center;
  vertical-align : middle;
  empty-cells : show;
  border-style : solid;
  border-width : 1px;
  border-color : #ffc080;
  width : 22px;
  height : 22px;
}
td.left-small {
  text-align : left;
  font-size : 8pt;
  padding : 0px 4px;
}
td.left-small-white {
  text-align : left;
  font-size : 8pt;
  padding : 0px 4px;
  background-color : #ffffff;
}
td.right-small {
  text-align : right;
  font-size : 8pt;
  padding : 0px 4px;
}
td.right-small-white {
  text-align : right;
  font-size : 8pt;
  padding : 0px 4px;
  background-color : #ffffff;
}
th {
  padding : 0px 0px;
  vertical-align : middle;
}
#menu {
  margin: 0px 0px 0px 0px;
  padding: 0px;
  height: 32px;
}
#menu ul {
  margin: 0px;
  padding: 0px;
  list-style: none;
  text-align: center;
  clear: both;
}
#menu li {
  margin: 0px 5px 0px 0px;
  padding: 0px;
  float: left;
}
#menu a {
  display: block;
  padding: 2px 4px;
  text-decoration: none;
  margin: 0px;
  font-weight: bold;
  background: #FFFFFF;
  color: #333333;
  border: 1px solid #666666;
}
#menu a:hover {
  display: block;
  padding: 2px 4px;
  border-bottom: 1px solid #000000;
  text-decoration: none;
  background: #FFCC66;
}
#menu .current {
  background-color: #F45F57;
  font-weight: bold;
  color: #FFFFFF;
  border: 1px solid #333333;
}
-->
</style>
<title>ソフトウェア工学IIの小テスト「樹状整列」プログラム</title>
</head>
<body>
<div id="menu">
<ul>
  <li><a href="../index.html">ホーム</a></li>
  <li><a href="../Requirement/index.html">要求仕様書</a></li>
  <li><a href="../DevelopmentPlan/index.html">開発計画書</a></li>
  <li><a href="../BasicDesign/index.html">基本設計書</a></li>
  <li><a href="../DetailDesign/index.html">詳細設計書</a></li>
  <li><a href="../TestSpecification/index.html">テスト仕様書</a></li>
  <li><a href="../TestResult/index.html">テスト結果</a></li>
  <li><a href="../DevelopmentResult/index.html">開発実績</a></li>
  <li><a href="../Program/index.html" class="current">プログラム</a></li>
  <li><a href="../Manual/index.html">マニュアル</a></li>
</ul>
</div>
<hr>
<h2>ソフトウェア工学IIの小テスト「樹状整列」プログラム</h2>
<ul>
    <li><a href="#Model">Model</a>（モデル）</li>
    <li><a href="#View">View</a>（ビュー）</li>
    <li><a href="#Controller">Controller</a>（コントローラ）</li>
</ul>
<ul>
    <li><a href="#Example">Example</a>（メインクラス）</li>
    <li><a href="#TreeModel">TreeModel</a>（ツリーモデル）</li>
    <li><a href="#TreeView">TreeView</a>（ツリービュー）</li>
    <li><a href="#TreeController">TreeController</a>（ツリーコントローラ）</li>
    <li><a href="#TreeLiteral">TreeLiteral</a>（ツリーリテラル）</li>
    <li><a href="#Tree">Tree</a>（ツリー）</li>
    <li><a href="#Leaf">Leaf</a>（リーフ）</li>
    <li><a href="#Branch">Branch</a>（ブランチ）</li>
</ul>
<ul>
    <li><a href="#tree.mf">tree.mf</a>（マニフェストファイル）</li>
    <li><a href="#Makefile">Makefile</a>（メイクファイル）</li>
    <li><a href="#build.xml">build.xml</a>（ビルドファイル）</li>
    </ul>
    <div class="belt">
        <h3><a name="Model" href="../TestSpecification/index.html#Model">Model（モデル）</a></h3>
    </div>
    <pre>package mvc;
        
        import java.awt.image.BufferedImage;
        import java.io.File;
        import java.util.ArrayList;
        import java.util.Iterator;
        
        /**
        * モデル。
        */
        public class Model extends Object
        {
        /**
        * 依存物（Observerデザインパターンの観測者）：Viewのインスタンスたちを束縛する。
        * 良好（2010年7月25日）
        */
        protected ArrayList&lt;View&gt; dependents;
        
        /**
        * 内容物として画像を束縛する。
        * 良好（2010年7月25日）
        */
        private BufferedImage picture;
        
        /**
        * インスタンスを生成して初期化して応答する。
        * 良好（2010年7月25日）
        */
        public <a name="Model-Model">Model()</a>
        {
        super();
        this.initialize();
        }
        
        /**
        * 指定されたビューを依存物に設定する。
        * 良好（2010年7月25日）
        */
        public void <a name="Model-addDependent">addDependent(View aView)</a>
        {
        dependents.add(aView);
        return;
        }
        
        /**
        * モデルの内部状態が変化していたので、自分の依存物へupdateのメッセージを送信する。
        * 良好（2010年7月25日）
        */
        public void <a name="Model-changed">changed()</a>
        {
        Iterator anIterator = dependents.iterator();
        while (anIterator.hasNext())
        {
        View aView = (View)anIterator.next();
        aView.update();
        }
        return;
        }
        
        /**
        * 初期化する。
        * 良好（2010年7月25日）
        */
        private void <a name="Model-initialize">initialize()</a>
        {
        dependents = new ArrayList&lt;View&gt;();
        picture = null;
        return;
        }
        
        /**
        * 何もしない。
        * 良好（2010年7月25日）
        */
        public void <a name="Model-perform">perform()</a>
        {
        return;
        }
        
        /**
        * 画像（モデルの内容物）を応答する。
        * 良好（2010年7月25日）
        */
        protected BufferedImage <a name="Model-picture">picture()</a>
        {
        return picture;
        }
        
        /**
        * 画像（モデルの内容物）を設定する。
        * 良好（2010年7月25日）
        */
        public void <a name="Model-picture2">picture(BufferedImage anImage)</a>
        {
        picture = anImage;
        return;
        }
        
        /**
        * このインスタンスを文字列にして応答する。
        * 良好（2010年7月25日）
        */
        public String <a name="Model-toString">toString()</a>
        {
        StringBuffer aBuffer = new StringBuffer();
        Class aClass = this.getClass();
        aBuffer.append(aClass.getName());
        aBuffer.append(&quot;[picture=&quot;);
        aBuffer.append(picture);
        aBuffer.append(&quot;]&quot;);
        return aBuffer.toString();
        }
        }
    </pre>
    <div class="belt">
        <h3><a name="View" href="../TestSpecification/index.html#View">View（ビュー）</a></h3>
    </div>
    <pre>package mvc;
        
        import java.awt.Point;
        import java.awt.Graphics;
        import java.awt.image.BufferedImage;
        import javax.swing.JPanel;
        import java.awt.Color;
        
        /**
        * ビュー。
        */
        public class View extends JPanel
        {
        /**
        * 情報を握っているModelのインスタンスを束縛する。
        * 束縛されるModelのインスタンスはpicture()というメッセージに応答できなければならない。
        * 良好（2010年7月25日）
        */
        protected Model model;
        
        /**
        * 制御を司るControllerのインスタンスを束縛する。
        * 良好（2010年7月25日）
        */
        protected Controller controller;
        
        /**
        * スクロール量としてPointのインスタンスを束縛する。
        * 良好（2010年7月25日）
        */
        private Point offset;
        
        /**
        * インスタンスを生成して応答する。
        * 指定されたモデルの依存物となり、コントローラを作り、モデルとビューを設定し、スクロール量を(0, 0)に設定する。
        * 良好（2010年7月25日）
        */
        public <a name="View-View">View(Model aModel)</a>
        {
        super();
        model = aModel;
        model.addDependent(this);
        controller = new Controller();
        controller.setModel(model);
        controller.setView(this);
        offset = new Point(0, 0);
        }
        
        /**
        * インスタンスを生成して応答する。
        * 指定されたモデルの依存物となり、指定されたコントローラにモデルとビューを設定し、スクロール量を(0, 0)に設定する。
        * 良好（2010年7月25日）
        */
        public <a name="View-View-View">View(Model aModel, Controller aController)</a>
        {
        super();
        model = aModel;
        model.addDependent(this);
        controller = aController;
        controller.setModel(model);
        controller.setView(this);
        offset = new Point(0, 0);
        }
        
        /**
        * 指定されたグラフィクスに背景色（灰色）でビュー全体を塗り、その後にモデルの内容物を描画する。
        * それはスクロール量（offset）を考慮してモデル画像（picture）をペイン（パネル）内に描画することである。
        * 良好（2010年7月25日）
        */
        public void <a name="View-paintComponent">paintComponent(Graphics aGraphics)</a>
        {
        int width = this.getWidth();
        int height = this.getHeight();
        aGraphics.setColor(Color.gray);
        aGraphics.fillRect(0, 0, width, height);
        if (model == null) { return; }
        BufferedImage picture = model.picture();
        if (picture == null) { return; }
        aGraphics.drawImage(picture, offset.x, offset.y, null);
        return;
        }
        
        /**
        * スクロール量（offsetの逆向きの大きさ）を応答する。
        * 良好（2010年7月25日）
        */
        public Point <a name="View-scrollAmount">scrollAmount()</a>
        {
        int x = 0 - offset.x;
        int y = 0 - offset.y;
        return (new Point(x, y));
        }
        
        /**
        * スクロール量を指定された座標分だけ相対スクロールする。
        * 良好（2010年7月25日）
        */
        public void <a name="View-scrollBy">scrollBy(Point aPoint)</a>
        {
        int x = offset.x + aPoint.x;
        int y = offset.y + aPoint.y;
        this.scrollTo(new Point(x, y));
        return;
        }
        
        /**
        * スクロール量を指定された座標に設定（絶対スクロール）する。
        * 良好（2010年7月25日）
        */
        public void <a name="View-scrollTo">scrollTo(Point aPoint)</a>
        {
        offset = aPoint;
        return;
        }
        
        /**
        * このインスタンスを文字列にして応答する。
        * 良好（2010年7月25日）
        */
        public String <a name="View-toString">toString()</a>
        {
        StringBuffer aBuffer = new StringBuffer();
        Class aClass = this.getClass();
        aBuffer.append(aClass.getName());
        aBuffer.append(&quot;[model=&quot;);
        aBuffer.append(model);
        aBuffer.append(&quot;,offset=&quot;);
        aBuffer.append(offset);
        aBuffer.append(&quot;]&quot;);
        return aBuffer.toString();
        }
        
        /**
        * ビューの全領域を再描画する。
        * 良好（2010年7月25日）
        */
        public void <a name="View-update">update()</a>
        {
        this.repaint(0, 0, this.getWidth(), this.getHeight());
        return;
        }
        }
    </pre>
    <div class="belt">
        <h3><a name="Controller" href="../TestSpecification/index.html#Controller">Controller（コントローラ）</a></h3>
    </div>
    <pre>package mvc;
        
        import java.awt.Component;
        import java.awt.Cursor;
        import java.awt.Point;
        import java.awt.event.MouseEvent;
        import java.awt.event.MouseWheelEvent;
        import java.awt.event.MouseWheelListener;
        import javax.swing.event.MouseInputAdapter;
        
        /**
        * コントローラ。
        */
        public class Controller extends MouseInputAdapter implements MouseWheelListener
        {
        /**
        * 情報を握っているModelのインスタンスを束縛する。
        * 良好（2010年7月25日）
        */
        protected Model model;
        
        /**
        * 表示を司るViewのインスタンスを束縛する。
        * 良好（2010年7月25日）
        */
        protected View view;
        
        /**
        * 以前にマウスのボタンが押下された場所をPointのインスタンスとして束縛する。
        * 良好（2010年7月25日）
        */
        private Point previous;
        
        /**
        * 現在にマウスのボタンが押下された場所をPointのインスタンスとして束縛する。
        * 良好（2010年7月25日）
        */
        private Point current;
        
        /**
        * インスタンスを生成して応答する。
        * すべてのインスタンス変数（model, view, previous, current）をnull化する。
        * 良好（2010年7月25日）
        */
        public <a name="Controller-Controller">Controller()</a>
        {
        super();
        model = null;
        view = null;
        previous = null;
        current = null;
        }
        
        /**
        * 指定されたマウスイベントからマウスカーサの位置を獲得して、モデル座標系でのクリック位置を割り出して標準出力に出力する。
        * 良好（2010年7月25日）
        */
        public void <a name="Controller-mouseClicked">mouseClicked(MouseEvent aMouseEvent)</a>
        {
        Point aPoint = aMouseEvent.getPoint();
        aPoint.translate(view.scrollAmount().x, view.scrollAmount().y);
        System.out.println(aPoint);
        return;
        }
        
        /**
        * マウスカーサの形状を移動の形に変化させ、指定されたマウスイベントからマウスカーサの位置を獲得して、
        * インスタンス変数currentに設定すると共に、以前のマウスカーサの位置からの差分を計算する。
        * そして、その差分だけビューに対してスクロールを依頼し、その後にビューの再描画を依頼する。
        * 最後にインスタンス変数previousをインスタンス変数currentに更新する。
        * 良好（2010年7月25日）
        */
        public void <a name="Controller-mouseDragged">mouseDragged(MouseEvent aMouseEvent)</a>
        {
        Cursor aCursor = Cursor.getPredefinedCursor(Cursor.MOVE_CURSOR);
        Component aComponent = (Component)aMouseEvent.getSource();
        aComponent.setCursor(aCursor);
        current = aMouseEvent.getPoint();
        int x = current.x - previous.x;
        int y = current.y - previous.y;
        Point point = new Point(x, y);
        view.scrollBy(point);
        view.repaint();
        previous = current;
        return;
        }
        
        /**
        * 何もしない。
        * 良好（2010年7月25日）
        */
        public void <a name="Controller-mouseEntered">mouseEntered(MouseEvent aMouseEvent)</a>
        {
        return;
        }
        
        /**
        * 何もしない。
        * 良好（2010年7月25日）
        */
        public void <a name="Controller-mouseExited">mouseExited(MouseEvent aMouseEvent)</a>
        {
        return;
        }
        
        /**
        * 何もしない。
        * 良好（2010年7月25日）
        */
        public void <a name="Controller-mouseMoved">mouseMoved(MouseEvent aMouseEvent)</a>
        {
        return;
        }
        
        /**
        * マウスカーサの形状を十字に変化させ、指定されたマウスイベントからマウスカーサの位置を獲得して、
        * インスタンス変数currentに設定する共にインスタンス変数previousをインスタンス変数currentに更新する。
        * 良好（2010年7月25日）
        */
        public void <a name="Controller-mousePressed">mousePressed(MouseEvent aMouseEvent)</a>
        {
        Cursor aCursor = Cursor.getPredefinedCursor(Cursor.CROSSHAIR_CURSOR);
        Component aComponent = (Component)aMouseEvent.getSource();
        aComponent.setCursor(aCursor);
        current = aMouseEvent.getPoint();
        previous = current;
        return;
        }
        
        /**
        * マウスカーサの形状をデフォルトに戻し、指定されたマウスイベントからマウスカーサの位置を獲得して、
        * インスタンス変数currentに設定する共にインスタンス変数previousをインスタンス変数currentに更新する。
        * 良好（2010年7月25日）
        */
        public void <a name="Controller-mouseReleased">mouseReleased(MouseEvent aMouseEvent)</a>
        {
        Cursor aCursor = Cursor.getDefaultCursor();
        Component aComponent = (Component)aMouseEvent.getSource();
        aComponent.setCursor(aCursor);
        current = aMouseEvent.getPoint();
        previous = current;
        return;
        }
        
        /**
        * 何もしない。
        * 良好（2010年7月25日）
        */
        public void <a name="Controller-mouseWheelMoved">mouseWheelMoved(MouseWheelEvent aMouseWheelEvent)</a>
        {
        return;
        }
        
        /**
        * 指定されたモデルをインスタンス変数modelに設定する。
        * 良好（2010年7月25日）
        */
        public void <a name="Controller-setModel">setModel(Model aModel)</a>
        {
        model = aModel;
        return;
        }
        
        /**
        * 指定されたビューをインスタンス変数viewに設定し、ビューのマウスのリスナおよびモーションリスナそしてホイールリスナをこのコントローラにする。
        * 良好（2010年7月25日）
        */
        public void <a name="Controller-setView">setView(View aView)</a>
        {
        view = aView;
        view.addMouseListener(this);
        view.addMouseMotionListener(this);
        view.addMouseWheelListener(this);
        return;
        }
        
        /**
        * このインスタンスを文字列にして応答する。
        * 良好（2010年7月25日）
        */
        public String <a name="Controller-toString">toString()</a>
        {
        StringBuffer aBuffer = new StringBuffer();
        Class aClass = this.getClass();
        aBuffer.append(aClass.getName());
        aBuffer.append(&quot;[model=&quot;);
        aBuffer.append(model);
        aBuffer.append(&quot;,view=&quot;);
        aBuffer.append(view);
        aBuffer.append(&quot;]&quot;);
        return aBuffer.toString();
        }
        }
    </pre>
    <div class="belt">
        <h3><a name="Example" href="../TestSpecification/index.html#Example">Example（メインクラス）</a></h3>
    </div>
    <pre>package tree;
        
        import java.awt.Dimension;
        
        import javax.swing.JFrame;
        
        /**
        * 例題プログラム。
        */
        public class Example extends Object
        {
        /**
        * TreeModel、TreeController、TreeViewクラスを作成。
        * その後Windowを作成している。
        */
        public static void <a name="Example-main">main(String[] args)</a>
        {
		String fileName = args[0];
		
		TreeModel aTreeModel = new TreeModel(fileName);
		TreeController aTreeController = new TreeController();
		TreeView aTreeView = new TreeView(aTreeModel, aTreeController);
        
		JFrame aWindow;
		aWindow = new JFrame(&quot;TreeLine&quot;);
		aWindow.getContentPane().add(aTreeView);
		aWindow.setMinimumSize(new Dimension(400, 300));
		aWindow.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
		aWindow.setSize(800, 800);
		aWindow.setLocation((200), (100));
		aWindow.setVisible(true);
        }
        }
    </pre>
    <div class="belt">
        <h3><a name="TreeModel" href="../TestSpecification/index.html#TreeModel">TreeModel（ツリーモデル）</a></h3>
    </div>
    <pre>package tree;
        
        import java.io.BufferedReader;
        import java.io.File;
        import java.io.FileInputStream;
        import java.io.FileNotFoundException;
        import java.io.IOException;
        import java.io.InputStreamReader;
        import java.io.UnsupportedEncodingException;
        import java.util.ArrayList;
        import java.util.TreeMap;
        
        /**
        * ツリーモデル。
        */
        public class TreeModel extends mvc.Model
        {
        /**
        * 木を束縛する。
        */
        private Tree aTree;
        
        /**
        * インスタンスを生成して、テキストファイルを読み込む。
        */
        public <a name="TreeModel-TreeModel">TreeModel(String fileName)</a>
        {
        super();
        aTree=new Tree();
        this.load(fileName);
        }
        
        /**
        * 木を応答する。
        * @return aTree 木
        */
        public Tree <a name="TreeModel-getTree">getTree()</a>
        {
        return this.aTree;
        }
        
        /**
        * ファイルを読み込む。
        */
        public void <a name="TreeModel-load">load(String fileName)</a>
        {
        //カレントディレクトリを取得 テスト用
        File currentDirectory = new File(&quot;.&quot;);
        System.out.println(currentDirectory.getAbsolutePath());
        
        // 入力ファイル名
        String inFileName = &quot;../../Requirement/texts/&quot;+fileName;
        
        try
        {
        FileInputStream fis = new FileInputStream(inFileName);
        InputStreamReader isr = new InputStreamReader(fis , &quot;UTF-8&quot;);
        BufferedReader br = new BufferedReader(isr);
        
        String line;
        boolean nodes = false;
        boolean branches = false;
        boolean trees = false;
        TreeMap&lt;Integer,String&gt; nodesMap = new TreeMap&lt;Integer,String&gt;();
        ArrayList&lt;Integer&gt; nodeDepthList = new ArrayList&lt;Integer&gt;();
        
        while((line=br.readLine()) != null)
        {
        if(line.equals(&quot;trees:&quot;))
        {
        branches = false;
        nodes = false;
        trees = true;
        line=br.readLine();
        }
        if(line.equals(&quot;nodes:&quot;))
        {
        branches = false;
        nodes = true;
        trees = false;
        line=br.readLine();
        }
        if(line.equals(&quot;branches:&quot;))
        {
        branches = true;
        nodes = false;
        trees = false;
        line=br.readLine();
        }
        if(trees)
        {
        Integer nodeDepth = 0;
        String nodeName;
        
        // 一行の中の改行文字を全て削除し、&quot;|--&quot;で分割
        String[] item = line.replaceAll(&quot;\n&quot;,&quot;&quot;).split(&quot;\\|-- &quot;);
        if (item.length == 1)
        {
        // 深さ0のとき
        nodeDepth = 0;
        nodeName = item[0];
        nodeDepthList.add(nodeDepth);
        }
        else
        {
        // 深さ0以外のとき
        // 深さ = 分割後の配列の長さ - 1
        nodeDepth = item.length - 1;
        nodeName = item[item.length - 1];
        nodeDepthList.add(nodeDepth);
        }
        }
        
        if(nodes)
        {
        // 1行の中の改行文字を全て削除し、,で分割
        String[] item = line.replaceAll(&quot;¥n&quot;, &quot;&quot;).split(&quot;, &quot;);
        // 分割結果の0番目はキー, 1番目はノードの名前
        Integer key = Integer.valueOf(item[0]);
        String nodeName  = item[1];
        // keyが初めて出てきたキーならば、TreeMapの値として追加
        if(!nodesMap.containsKey(key))
        {
        nodesMap.put(key, nodeName);
        }
        Leaf aLeaf = new Leaf(key, nodeName);
        aTree.addLeafList(aLeaf);
        }
        if(branches)
        {
        String[] item = line.replaceAll(&quot;¥n&quot;,&quot;&quot;).split(&quot;, &quot;);
        Integer from = Integer.valueOf(item[0]);
        Integer to = Integer.valueOf(item[1]);
        try
        {
        Leaf aLeaf = aTree.getLeafList().get(from-1);
        Leaf childLeaf = aTree.getLeafList().get(to-1);
        aLeaf.addChildLeaf(childLeaf);
        childLeaf.addParent(aLeaf);
        }
        catch (Exception e)
        {
        // TODO: handle exception
        e.printStackTrace();
        }
        Branch aBranch = new Branch(from,to);
        aTree.setBranch(aBranch);
        aTree.addBranchList(aBranch);
        }
        }
        // 子孫の情報を各葉に保存
        for (Leaf aLeaf : aTree.getLeafList())
        {
        aLeaf.setDescendantLeaves();
        }
        br.close();
        isr.close();
        fis.close();
        
        }
        catch (FileNotFoundException e)
        {
        e.printStackTrace();
        } catch (UnsupportedEncodingException e)
        {
        e.printStackTrace();
        }
        catch (IOException e)
        {
        e.printStackTrace();
        }
        
        return;
        
        }
        }
    </pre>
    <div class="belt">
        <h3><a name="TreeView" href="../TestSpecification/index.html#TreeView">TreeView（ツリービュー）</a></h3>
    </div>
    <pre>package tree;
        
        import java.awt.Color;
        import java.awt.Graphics;
        import java.awt.Point;
        import java.awt.Rectangle;
        
        /**
        * ツリービュー。
        */
        public class TreeView extends mvc.View
        {
        /**
        * TreeModelを束縛する。
        */
        protected TreeModel aTreeModel;
        
        /**
        * TreeControllerを束縛する。
        */
        protected TreeController aTreeController;
        
        /**
        * スクロール量としてPointのインスタンスを束縛する。
        */
        private Point offset;
        
        /**
        * インスタンスを生成して応答する。
        * 指定されたツリーモデルの依存物となり、ツリーコントローラを作り、ツリーモデルとツリービューを設定し、スクロール量を(0, 0)に設定する。
        * @param aTreeModel
        * @param aTreeController
        */
        public <a name="TreeView-TreeView">TreeView(TreeModel aTreeModel,TreeController aTreeController)</a>
        {
		super(aTreeModel,aTreeController);
		this.aTreeModel=aTreeModel;
		this.aTreeController=aTreeController;
		this.aTreeController.setView(this);
		this.aTreeController.setModel(aTreeModel);
		offset = new Point(0, 0);
        }
        
        /**
        * 葉の位置を計算する再帰メソッド。不完全
        * TODO: TreeModelへ移動。アニメーション機能追加。
        * @param aLeaf 位置を計算する葉
        * @param count 何個目の子の葉か
        */
        private void <a name="TreeView-calcPosition">calcPosition(Leaf aLeaf, int count)</a>
        {
		// 葉に親が居ない場合
		if (aLeaf.isRoot())
		{
        if (!aLeaf.getChildLeaves().isEmpty())
        {
        int n=0;
        // 不完全: 描画位置が正しくない
        for (Leaf childLeaf : aLeaf.getChildLeaves())
        {
        calcPosition(childLeaf, n);
        n++;
        }
        //				calcPosition(aLeaf.getChildLeaves().get(0), 0);
        }
		}
		else
		{
        // 親の位置を元に自分の位置を計算
        //			System.out.println(aLeaf.getNodeName());
        Leaf parentLeaf = aLeaf.getParentLeaf();
        Rectangle parentLeafPos = parentLeaf.getPosition();
        int x = parentLeafPos.x + parentLeafPos.width + TreeLiteral.WIDTH_INTERVAL;
        int y = parentLeafPos.y + (parentLeafPos.height + TreeLiteral.HEIGHT_INTERVAL) * count;
        aLeaf.setPosition(x, y);
        this.add(aLeaf);
        
        if (!aLeaf.getChildLeaves().isEmpty())
        {
        // 子に対して再帰処理を行う。
        int i=0;
        for (Leaf childLeaf : aLeaf.getChildLeaves())
        {
        calcPosition(childLeaf, i);
        i++;
        }
        
        // 子の位置を再計算したあと、自分の位置を再計算する。
        int childsize = aLeaf.getChildLeaves().size();
        int center = (aLeaf.getPosition().height * childsize + TreeLiteral.HEIGHT_INTERVAL * (childsize - 1)) / childsize;
        y = y + center - (aLeaf.getPosition().height / 2);
        aLeaf.setPosition(x, y);
        }
        else
        {
        return;
        }
		}
		this.add(aLeaf);
        //		aLeaf.outPosition();
        }
        /**
        * 指定されたグラフィクスに背景色（白色）でツリービュー全体を塗り、
        * その後にスクロール量（offset）を考慮してリーフとブランチを描画する。
        */
        public void <a name="TreeView-paintComponent">paintComponent(Graphics aGraphics)</a>
        {
		int width;
		int height;
		width = this.getWidth();
		height = this.getHeight();
		aGraphics.setColor(Color.white);
		aGraphics.fillRect(0, 0, width, height);
		for ( Leaf aLeaf : aTreeModel.getTree().getLeafList() )
		{
        if (aLeaf.isRoot()) {
        aLeaf.setDefaultPosition(0, offset.x, offset.y);
        calcPosition(aLeaf, 0);
        }
	    }
		for ( Branch aBranch : aTreeModel.getTree().getBranchList() )
		{
        aGraphics.setColor(Color.black);
        Leaf from = aTreeModel.getTree().getLeafList().get(aBranch.getBranchFrom()-1);
        Leaf to = aTreeModel.getTree().getLeafList().get(aBranch.getBranchTo()-1);
        aGraphics.drawLine(from.getBounds().x+from.getSize().width, from.getBounds().y+from.getSize().height/2,
        to.getBounds().x, to.getBounds().y+to.getSize().height/2);
		}
		return;
        }
        
        /**
        * スクロール量（offsetの逆向きの大きさ）を応答する。
        */
        public Point <a name="TreeView-scrollAmount">scrollAmount()</a>
        {
		int x = 0 - offset.x;
		int y = 0 - offset.y;
		return (new Point(x, y));
        }
        
        /**
        * スクロール量を指定された座標分だけ相対スクロールする。
        */
        public void <a name="TreeView-scrollBy">scrollBy(Point aPoint)</a>
        {
		int x = offset.x + aPoint.x;
		int y = offset.y + aPoint.y;
		this.scrollTo(new Point(x, y));
		return;
        }
        
        /**
        * スクロール量を指定された座標に設定（絶対スクロール）する。
        */
        public void <a name="TreeView-scrollTo">scrollTo(Point aPoint)</a>
        {
		offset = aPoint;
		return;
        }
        
        }
    </pre>
    <div class="belt">
        <h3><a name="TreeController" href="../TestSpecification/index.html#TreeController">TreeController（ツリーコントローラー）</a></h3>
    </div>
    <pre>package tree;
        
        import java.awt.Component;
        import java.awt.Cursor;
        import java.awt.Point;
        import java.awt.event.MouseEvent;
        
        /**
        * ツリーコントローラー。
        */
        public class TreeController extends mvc.Controller
        {
        
        /**
        * TreeModelを束縛する。
        */
        protected TreeModel aTreeModel;
        
        /**
        * TreeViewを束縛する。
        */
        protected TreeView aTreeView;
        
        /**
        * 以前にマウスのボタンが押下された場所をPointのインスタンスとして束縛する。
        */
        private Point previous;
        
        /**
        * 現在にマウスのボタンが押下された場所をPointのインスタンスとして束縛する。
        */
        private Point current;
        
        /**
        * インスタンスを生成して応答する。
        * すべてのインスタンス変数（aTreeModel, aTreeView, previous, current）をnull化する。
        */
        public <a name="TreeController-TreeController">TreeController()</a>
        {
		super();
		aTreeModel=null;
		aTreeView=null;
		previous = null;
		current = null;
        }
		
        /**
        * 指定されたマウスイベントからマウスカーサの位置を獲得して、モデル座標系でのクリック位置を割り出して、
        * Leafに位置座標の情報を送信する。
        */
        public void <a name="TreeController-mouseClicked">mouseClicked(MouseEvent aMouseEvent)</a>
        {
		Point aPoint = aMouseEvent.getPoint();
		aPoint.translate(view.scrollAmount().x, view.scrollAmount().y);
		return;
        }
        
        /**
        * マウスカーサの形状を移動の形に変化させ、指定されたマウスイベントからマウスカーサの位置を獲得して、
        * インスタンス変数currentに設定すると共に、以前のマウスカーサの位置からの差分を計算する。
        * そして、その差分だけビューに対してスクロールを依頼し、その後にビューの再描画を依頼する。
        * 最後にインスタンス変数previousをインスタンス変数currentに更新する。
        */
        public void <a name="TreeController-mouseDragged">mouseDragged(MouseEvent aMouseEvent)</a>
        {
		Cursor aCursor = Cursor.getPredefinedCursor(Cursor.MOVE_CURSOR);
		Component aComponent = (Component)aMouseEvent.getSource();
		aComponent.setCursor(aCursor);
		current = aMouseEvent.getPoint();
		int x = current.x - previous.x;
		int y = current.y - previous.y;
		Point point = new Point(x, y);
		aTreeView.scrollBy(point);
		aTreeView.repaint();
		previous = current;
		return;
        }
        
        /**
        * マウスカーサの形状を十字に変化させ、指定されたマウスイベントからマウスカーサの位置を獲得して、
        * インスタンス変数currentに設定する共にインスタンス変数previousをインスタンス変数currentに更新する。
        */
        public void <a name="TreeController-mousePressed">mousePressed(MouseEvent aMouseEvent)</a>
        {
		Cursor aCursor = Cursor.getPredefinedCursor(Cursor.CROSSHAIR_CURSOR);
		Component aComponent = (Component)aMouseEvent.getSource();
		aComponent.setCursor(aCursor);
		current = aMouseEvent.getPoint();
		previous = current;
		return;
        }
        
        /**
        * マウスカーサの形状をデフォルトに戻し、指定されたマウスイベントからマウスカーサの位置を獲得して、
        * インスタンス変数currentに設定する共にインスタンス変数previousをインスタンス変数currentに更新する。
        */
        public void <a name="TreeController-mouseReleased">mouseReleased(MouseEvent aMouseEvent)</a>
        {
		Cursor aCursor = Cursor.getDefaultCursor();
		Component aComponent = (Component)aMouseEvent.getSource();
		aComponent.setCursor(aCursor);
		current = aMouseEvent.getPoint();
		previous = current;
		return;
        }
        
        /**
        *  指定されたモデルをインスタンス変数aTreeModelに設定する。
        * @param aTreeModel
        */
        public void <a name="TreeController-setModel">setModel(TreeModel aTreeModel)</a>
        {
		this.aTreeModel = aTreeModel;
        return;
        }
        
        /**
        * 指定されたビューをインスタンス変数aTreeViewに設定し、
        * ツリービューのマウスのリスナおよびモーションリスナそしてホイールリスナをこのコントローラにする。
        * @param aTreeView
        */
        public void <a name="TreeController-setView">setView(TreeView aTreeView)</a>
        {
		this.aTreeView = aTreeView;
		aTreeView.addMouseListener(this);
		aTreeView.addMouseMotionListener(this);
		aTreeView.addMouseWheelListener(this);
        return;	
        }
        }
    </pre>
    <div class="belt">
        <h3><a name="TreeLiteral" href="../TestSpecification/index.html#TreeLiteral">TreeLiteral（ツリーリテラル）</a></h3>
    </div>
    <pre>package tree;
        
        /**
        * 定数を保持するクラス
        */
        public class TreeLiteral
        {
        /**
        * フォントのサイズを束縛するリテラル。
        */
        static final int FONT_SIZE = 12;
        
        /**
        * ノードの枠線のサイズを束縛するリテラル。
        */
        static final int BORDERLINE_SIZE = 1;
        
        /**
        * ノードの縦の間隔を束縛するリテラル。
        */
        static final int HEIGHT_INTERVAL = 2;
        
        /**
        * ノードの横の間隔を束縛するリテラル。
        */
        static final int WIDTH_INTERVAL = 25;
        
        }
    </pre>
    <div class="belt">
        <h3><a name="Tree" href="../TestSpecification/index.html#Tree">Tree（ツリー）</a></h3>
    </div>
    <pre>package tree;
        
        import java.util.ArrayList;
        
        /**
        * ツリー。
        */
        public class Tree
        {
        /**
        * Leafのインスタンスたちを束縛する。
        */
        private ArrayList&lt;Leaf&gt; aLeafList;
        
        /**
        * Branchのインスタンスたちを束縛する。
        */
        private ArrayList&lt;Branch&gt; aBranchList;
        
        /**
        * 枝を束縛する。
        */
        private Branch aBranch;
        
        /**
        * 葉を束縛する。
        */
        private Leaf aLeaf;
        
        /**
        * ツリーを作るコンストラクタ。
        */
        public <a name="Tree-Tree">Tree()</a>
        {
        aLeafList = new ArrayList&lt;Leaf&gt;();
        aBranchList = new ArrayList&lt;Branch&gt;();
        }
        
        /**
        * 葉を設定する。
        * @param aLeaf
        */
        public void <a name="Tree-setLeaf">setLeaf(Leaf aLeaf)</a>
        {
        this.aLeaf = aLeaf;
        return;
        }
        
        /**
        * 葉を応答する。
        * @return aLeaf 葉
        */
        public Leaf <a name="Tree-getLeaf">getLeaf()</a>
        {
        return this.aLeaf;
        }
        
        /**
        * 葉をリストに追加する。
        * @param aLeaf
        */
        public void <a name="Tree-addLeafList">addLeafList(Leaf aLeaf)</a>
        {
        aLeafList.add(aLeaf);
        return;
        }
        
        /**
        * 葉のリストを応答する。
        * @return aLeafList 葉のリスト
        */
        public ArrayList&lt;Leaf&gt; <a name="Tree-getLeafList">getLeafList()</a>
        {
        return this.aLeafList;
        }
        
        /**
        * 枝を応答する。
        * @return aBranch 枝
        */
        public Branch <a name="Tree-getBranch">getBranch()</a>
        {
        return aBranch;
        }
        
        /**
        * 枝を設定する。
        * @param aBranch
        */
        public void <a name="Tree-setBranch">setBranch(Branch aBranch)</a>
        {
        this.aBranch = aBranch;
        return;
        }
        
        /**
        * 枝のリストを応答する。
        * @return aBranchList 枝のリスト
        */
        public ArrayList&lt;Branch&gt; <a name="Tree-getBranchList">getBranchList()</a>
        {
        return aBranchList;
        }
        
        /**
        * 枝をリストに追加する。
        * @param aBranch
        */
        public void <a name="Tree-addBranchList">addBranchList(Branch aBranch)</a>
        {
        aBranchList.add(aBranch);
        return;
        }
        }
    </pre>
    <div class="belt">
        <h3><a name="Leaf" href="../TestSpecification/index.html#Leaf">Leaf（リーフ）</a></h3>
    </div>
    <pre>package tree;
        
        import java.awt.Color;
        import java.awt.Component;
        import java.awt.Cursor;
        import java.awt.Font;
        import java.awt.Rectangle;
        import java.awt.event.MouseEvent;
        import java.awt.event.MouseListener;
        import java.util.ArrayList;
        import java.util.Map;
        import java.util.TreeMap;
        
        import javax.swing.JLabel;
        import javax.swing.border.LineBorder;
        
        /**
        *リーフ。
        */
        public class Leaf extends JLabel implements MouseListener
        {
        
        /**
        * ノードの名前を束縛する。
        */
        private String nodeName;
        
        /**
        * ノードの番号を束縛する。
        */
        private Integer nodeNumber;
        
        /**
        * ノードの深さを束縛する。
        */
        private Integer nodeDepth;
        
        /**
        * 次のノードの番号を束縛する。
        */
        private ArrayList&lt;Integer&gt; nextNodeNumber;
            
        /**
        * 葉に親がいるかどうか
        */
        private boolean root = true;
            
        /**
        * 親を束縛する。
        */
        private Leaf parentLeaf;
            
        /**
        * 子を束縛する。
        */
        private ArrayList&lt;Leaf&gt; childLeaves;
                
        /**
        * 子孫を束縛するTreeMap&lt;String:葉の名前, Leaf:葉&gt;
        */
        private TreeMap&lt;String, Leaf&gt; descendantLeaves;
                        
        /**
        * ノードの番号,名前,深さを指定して葉を作るコンストラクタ。
        * @param nodeNumber
        * @param nodeName
        * @param nodeDepth
        */
        public <a name="Leaf-Leaf">Leaf(Integer nodeNumber,String nodeName,Integer nodeDepth)</a>
        {
        this.nodeNumber=nodeNumber;
        this.nodeName=nodeName;
        this.nodeDepth=nodeDepth;
        this.nextNodeNumber=new ArrayList&lt;Integer&gt;();
        this.childLeaves=new ArrayList&lt;Leaf&gt;();
        this.descendantLeaves=new TreeMap&lt;String, Leaf&gt;();
        this.setText(nodeName);
        this.setFont(new Font(&quot;Serif&quot;, Font.PLAIN, TreeLiteral.FONT_SIZE));
        this.setBorder(new LineBorder(Color.BLACK,TreeLiteral.BORDERLINE_SIZE,false));
        this.setSize(this.getPreferredSize());
        this.addMouseListener(this);
        }
            
        /**
        * ノードの番号、名前を指定して葉を作るコンストラクタ。
        * ノードの深さを指定しない。
        * @param nodeNumber ノード番号
        * @param nodeName	ノードの名前
        */
        public <a name="Leaf-Leaf-Leaf">Leaf(Integer nodeNumber, String nodeName)</a>
        {
        this(nodeNumber, nodeName, null);
        //    	System.out.println(nodeNumber + &quot; &quot; + nodeName +  &quot;ノードの深さが未設定です。&quot;
        }
        
        /**
        * 葉に親がいるかいないかを尋ねる。
        * @return 親がいなければtrue居ればfalse
        */
        public boolean <a name="Leaf-isRoot">isRoot()</a>
        {
        return this.root;
        }
        
        /**
        * 葉に親を束縛する。
        * 親がいれば根では無いので、rootをfalseにする。
        * @param aLeaf 葉の親
        */
        public void <a name="Leaf-addParent">addParent(Leaf aLeaf)</a>
        {
        this.parentLeaf = aLeaf;
        this.root = false;
        }
        
        /**
        * 葉に子の情報を追加する。
        * @param aLeaf 葉の子
        */
        public void <a name="Leaf-addChildLeaf">addChildLeaf(Leaf aLeaf)</a>
        {
        childLeaves.add(aLeaf);
        }
        
        /**
        * 葉の親を返す
        * @return Leaf 葉の親
        */
        public Leaf <a name="Leaf-getParentLeaf">getParentLeaf()</a>
        {
        return this.parentLeaf;
        }
        
        /**
        * 子の情報を返す。
        * @return 子の葉(Leaf)のArrayList
        */
        public ArrayList&lt;Leaf&gt; <a name="Leaf-getChildLeaves">getChildLeaves()</a>
        {
        return this.childLeaves;
        }
        
        /**
        * ある葉が持つ子孫を全てTreeMapに登録するための再帰メソッド
        * @param aLeaf 葉
        * @param descendantLeaves 葉を登録するTreeMap
        */
        private void <a name="Leaf-addDescendantMap">addDescendantMap(Leaf aLeaf, TreeMap&lt;String, Leaf&gt; descendantLeaves)</a>
        {
        // 子がいる限りこのメソッドを再帰呼び出しする。
        for (Leaf aChildLeaf : aLeaf.getChildLeaves())
        {
        this.addDescendantMap(aChildLeaf, descendantLeaves);
        }
        // ダブり防止の為、自分(最初にこのメソッドを呼んだ葉)は登録しないようにする。
        if (aLeaf != this)
        {
        descendantLeaves.put(aLeaf.getNodeName(), aLeaf);
        }
        return;
        }
        
        /**
        * 葉が持つ子孫を葉の名前をキーとし、葉を値としてTreeMapに追加する。
        * 葉に子供の情報を持たせてから呼ぶ。
        */
        public void <a name="Leaf-setDescendantLeaves">setDescendantLeaves()</a>
        {
        this.addDescendantMap(this, this.descendantLeaves);
        // デバッグ用
        //    	System.out.println(&quot;  &quot; + this.nodeName);
        //    	for (Map.Entry&lt;String, Leaf&gt; entry: this.descendantLeaves.entrySet())
        //    	{
        //    		System.out.println(&quot;   &quot; + entry.getKey() + &quot; : &quot; + entry.getValue());
        //		}
        }
        
        /**
        * この葉の子孫を取得する。
        * @return 子孫が登録されたTreeMap &lt;葉の名前, 葉への参照&gt;
        */
        public TreeMap&lt;String, Leaf&gt; <a name="Leaf-getDescendantLeaves">getDescendantLeaves()</a>
        {
        return this.descendantLeaves;
        }
        
        /**
        * 現在の位置を出力する。
        */
        public void <a name="Leaf-outPosition">outPosition()</a>
        {
        System.out.println(&quot;x=&quot;+this.getX()+&quot; y=&quot;+this.getY()+&quot; width=&quot;+this.getWidth()+&quot; height=&quot;+this.getHeight()+&quot; :&quot;+nodeName);
        return;
        }
        
        /**
        * ノードの位置を設定する。
        * @param x
        * @param y
        */
        public void <a name="Leaf-setPosition">setPosition(int x, int y)</a>
        {
        this.setBounds(x ,y, this.getWidth(), this.getHeight());
        }
        
        /**
        * 樹上整列前のノードの位置を設定する。nはノード数。
        * @param n
        */
        public void <a name="Leaf-setDefaultPosition">setDefaultPosition(int n,int x,int y)</a>
        {
        this.setBounds(0 + x , (this.getHeight() * n + TreeLiteral.HEIGHT_INTERVAL * n) + y, this.getWidth(), this.getHeight());
        //    	System.out.println(&quot;x=&quot;+this.getX()+&quot; y=&quot;+this.getY()+&quot; width=&quot;+this.getWidth()+&quot; height=&quot;+this.getHeight()+&quot; :&quot;+nodeName);
        return;
        }
        
        /**
        * ノードの位置を応答する。
        * @return Rectangle ノードの位置(x, y)、幅(width)、高さ(height)
        */
        public Rectangle <a name="Leaf-getPosition">getPosition()</a>
        {
        return this.getBounds();
        }
        
        /**
        * ノードの名前を応答する。
        * @return nodeName ノードの名前
        */
        public String <a name="Leaf-getNodeName">getNodeName()</a>
        {
        return this.nodeName;
        }
        
        /**
        * ノードの名前を設定する。
        * @param nodeName
        */
        public void <a name="Leaf-setNodeName">setNodeName(String nodeName)</a>
        {
        this.nodeName = nodeName;
        return;
        }
        /**
        * ノードの番号を応答する。
        * @return nodeNumber ノードの番号
        */
        public Integer <a name="Leaf-getNodeNumber">getNodeNumber()</a>
        {
        return this.nodeNumber;
        }
        /**
        * ノードの番号を設定する。
        * @param nodeNumber
        */
        public void <a name="Leaf-setNodeNumber">setNodeNumber(Integer nodeNumber)</a>
        {
        this.nodeNumber = nodeNumber;
        return;
        }
        
        /**
        * ノードの深さを応答する。
        * @return nodeDepth ノードの深さ。
        */
        public Integer <a name="Leaf-getNodeDepth">getNodeDepth()</a>
        {
        return nodeDepth;
        }
        /**
        * ノードの深さを設定する。
        * @param nodeDepth
        */
        public void <a name="Leaf-setNodeDepth">setNodeDepth(Integer nodeDepth)</a>
        {
        this.nodeDepth = nodeDepth;
        return;
        }
        
        /**
        * ノードの名前を標準出力する。
        */
        public void <a name="Leaf-mouseClicked">mouseClicked(MouseEvent aMouseEvent)</a>
        {
        System.out.println(nodeName);
        }
        
        /**
        *何もしない。
        */
        public void <a name="Leaf-mouseExited">mouseExited(MouseEvent aMouseEvent)</a>
        {
        
        }
        
        /**
        * マウスカーサの形状をデフォルトに戻す。
        */
        public void <a name="Leaf-mousePressed">mousePressed(MouseEvent aMouseEvent)</a>
        {
        Cursor aCursor = Cursor.getDefaultCursor();
        Component aComponent = (Component)aMouseEvent.getSource();
        aComponent.setCursor(aCursor);
        }
        
        /**
        * マウスカーサの形状を手に変化させる。
        */
        public void <a name="Leaf-mouseReleased">mouseReleased(MouseEvent aMouseEvent)</a>
        {
        Cursor aCursor = Cursor.getPredefinedCursor(Cursor.HAND_CURSOR);
        Component aComponent = (Component)aMouseEvent.getSource();
        aComponent.setCursor(aCursor);
        }
        
        /**
        * マウスカーサの形状を手に変化させる。
        */
        public void <a name="Leaf-mouseEntered">mouseEntered(MouseEvent aMouseEvent)</a>
        {
        Cursor aCursor = Cursor.getPredefinedCursor(Cursor.HAND_CURSOR);
        Component aComponent = (Component)aMouseEvent.getSource();
        aComponent.setCursor(aCursor);
        }
        
        }
    </pre>
    <div class="belt">
        <h3><a name="Branch" href="../TestSpecification/index.html#Branch">Branch（ブランチ）</a></h3>
    </div>
    <pre>package tree;
        
        /**
        * ブランチ。
        */
        public class Branch
        {
        
        /**
        * 枝の根元を束縛する。
        */
        private Integer from;
        
        /**
        * 枝の終端を束縛する。
        */
        private Integer to;
        
        /**
        * 始点と終点を指定してブランチを作るコンストラクタ。
        */
        public <a name="Branch-Branch">Branch(Integer from,Integer to)</a>
        {
    	this.from=from;
    	this.to=to;
        }
        
        /**
        * 枝の根元を応答する。
        * @return from 枝の根元
        */
        public Integer <a name="Branch-getBranchFrom">getBranchFrom()</a>
        {
    	return this.from;
        }
        
        /**
        * 枝の根元を設定する。
        * @param from
        */
        public void <a name="Branch-setBranchFrom">setBranchFrom(Integer from)</a>
        {
    	this.from = from;
    	return;
        }
        
        /**
        * 枝の終端を応答する。
        * @return to 枝の終端
        */
        public Integer <a name="Branch-getBranchTo">getBranchTo()</a>
        {
    	return this.to;
        }
        
        /**
        * 枝の終端を設定する。
        * @param to
        */
        public void <a name="Branch-setBranchTo">setBranchTo(Integer to)</a>
        {
    	this.to = to;
    	return;
        }
        }
    </pre>
    <div class="belt">
        <h3><a name="tree.mf">tree.mf</a>（マニフェストファイル）</h3>
    </div>
    <pre>Manifest-Version: 1.0
        Main-Class: tree.Example</pre>
    <div class="belt">
        <h3><a name="Makefile">Makefile</a>（メイクファイル）</h3>
    </div>
    <pre>ANT	= env LC_ALL=ja_JP.UTF-8 ant
        
        all:
        $(ANT) all
        
        clean:
        $(ANT) clean
        
        treetest:
        $(ANT) treetest
        
        foresttest:
        $(ANT) foresttest
        
        semilatticetest:
        $(ANT) tsemilatticetest
        
        install:
        $(ANT) install
        
        doc:
        $(ANT) doc
        
        zip:
        $(ANT) zip
    </pre>
    <div class="belt">
        <h3><a name="build.xml">build.xml</a>（ビルドファイル）</h3>
    </div>
    <pre>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
        
        &lt;project name=&quot;TreeLine&quot; default=&quot;all&quot; basedir=&quot;.&quot;&gt;
        
        &lt;property name=&quot;package&quot; value=&quot;tree&quot; /&gt;
        &lt;property name=&quot;packagenames&quot; value=&quot;${package}&quot; /&gt;
        &lt;property name=&quot;destdir&quot; value=&quot;./Classes&quot; /&gt;
        &lt;property name=&quot;docdir&quot; value=&quot;./JavaDoc&quot; /&gt;
        &lt;property name=&quot;instdir&quot; value=&quot;./${ant.project.name}.app/Contents/Resources/Java&quot; /&gt;
        &lt;property name=&quot;copyright&quot; value=&quot;Copyright 2008-2011 TreeLine. All Right Reserved.&quot; /&gt;
        &lt;property name=&quot;zipname&quot; value=&quot;${ant.project.name}&quot; /&gt;
        
        &lt;tstamp&gt;
        &lt;format property=&quot;date&quot; pattern=&quot;yyyy/MM/dd&quot; /&gt;
        &lt;format property=&quot;time&quot; pattern=&quot;HH:mm:ss&quot; /&gt;
        &lt;/tstamp&gt;
        
        &lt;target name=&quot;all&quot; depends=&quot;jar&quot; description=&quot;build all&quot;&gt;
        &lt;echo&gt;on ${date} at ${time}&lt;/echo&gt;
        &lt;/target&gt;
        
        &lt;target name=&quot;prepare&quot; depends=&quot;&quot; description=&quot;prepare to compile&quot;&gt;
        &lt;mkdir dir=&quot;${destdir}&quot; /&gt;
        &lt;echo&gt;on ${date} at ${time}&lt;/echo&gt;
        &lt;/target&gt;
        
        &lt;target name=&quot;compile&quot; depends=&quot;prepare&quot; description=&quot;compile all sources&quot;&gt;
        &lt;javac
        srcdir=&quot;${basedir}&quot;
        destdir=&quot;${destdir}&quot;
        includeAntRuntime=&quot;true&quot;
        encoding=&quot;UTF-8&quot;
        deprecation=&quot;on&quot;
        verbose=&quot;false&quot;&gt;
        &lt;compilerarg value=&quot;-Xlint:unchecked&quot; /&gt;
        &lt;classpath&gt;
        &lt;pathelement location=&quot;.&quot; /&gt;
        &lt;/classpath&gt;
        &lt;/javac&gt;
        &lt;echo&gt;on ${date} at ${time}&lt;/echo&gt;
        &lt;/target&gt;
        
        &lt;target name=&quot;jar&quot; depends=&quot;compile&quot; description=&quot;make jar file&quot;&gt;
        &lt;jar
        jarfile=&quot;${package}.jar&quot;
        basedir=&quot;${destdir}&quot;
        manifest=&quot;${package}.mf&quot;&gt;
        &lt;/jar&gt;
        &lt;echo&gt;on ${date} at ${time}&lt;/echo&gt;
        &lt;/target&gt;
        
        &lt;target name=&quot;clean&quot; description=&quot;cleaning&quot;&gt;
        &lt;delete dir=&quot;${destdir}&quot; /&gt;
        &lt;delete file=&quot;${package}.jar&quot; /&gt;
        &lt;delete dir=&quot;${docdir}&quot; /&gt;
        &lt;delete dir=&quot;${instdir}&quot; /&gt;
        &lt;delete file=&quot;../${zipname}.zip&quot; /&gt;
        &lt;delete&gt;
        &lt;fileset dir=&quot;${package}&quot; includes=&quot;*.class&quot; /&gt;
        &lt;/delete&gt;
        &lt;echo&gt;on ${date} at ${time}&lt;/echo&gt;
        &lt;/target&gt;
        
        &lt;target name=&quot;treetest&quot; depends=&quot;all&quot; description=&quot;tree.txt&quot;&gt;
        &lt;exec executable=&quot;java&quot; spawn=&quot;false&quot;&gt;
        &lt;arg line=&quot;-Xmx512m -Xss1024k -jar ${package}.jar&quot; /&gt;
        &lt;arg line=&quot;tree.txt&quot; /&gt;
        &lt;/exec&gt;
        &lt;echo&gt;on ${date} at ${time}&lt;/echo&gt;
        &lt;/target&gt;
        
        &lt;target name=&quot;foresttest&quot; depends=&quot;all&quot; description=&quot;forest.txt&quot;&gt;
        &lt;exec executable=&quot;java&quot; spawn=&quot;false&quot;&gt;
        &lt;arg line=&quot;-Xmx512m -Xss1024k -jar ${package}.jar&quot; /&gt;
        &lt;arg line=&quot;forest.txt&quot; /&gt;
        &lt;/exec&gt;
        &lt;echo&gt;on ${date} at ${time}&lt;/echo&gt;
        &lt;/target&gt;
        
        &lt;target name=&quot;semilatticetest&quot; depends=&quot;all&quot; description=&quot;semilattice.txt&quot;&gt;
        &lt;exec executable=&quot;java&quot; spawn=&quot;false&quot;&gt;
        &lt;arg line=&quot;-Xmx512m -Xss1024k -jar ${package}.jar&quot; /&gt;
        &lt;arg line=&quot;semilattice.txt&quot; /&gt;
        &lt;/exec&gt;
        &lt;echo&gt;on ${date} at ${time}&lt;/echo&gt;
        &lt;/target&gt;
        
        &lt;target name=&quot;install&quot; depends=&quot;all&quot; description=&quot;install into application&quot;&gt;
        &lt;copy file=&quot;${package}.jar&quot; todir=&quot;${instdir}&quot;/&gt;
        &lt;exec executable=&quot;chmod&quot;&gt;
        &lt;arg line=&quot;755 ${instdir}/../../MacOS/applet&quot; /&gt;
        &lt;/exec&gt;
        &lt;echo&gt;on ${date} at ${time}&lt;/echo&gt;
        &lt;/target&gt;
        
        &lt;target name=&quot;doc&quot; depends=&quot;all&quot; description=&quot;make document (javadoc)&quot;&gt;
        &lt;mkdir dir=&quot;${docdir}&quot; /&gt;
        &lt;javadoc
        locale=&quot;en_US&quot;
        sourcepath=&quot;${basedir}&quot;
        destdir=&quot;${docdir}&quot;
        packagenames=&quot;${packagenames}&quot;
        author=&quot;true&quot;
        version=&quot;true&quot;
        charset=&quot;UTF-8&quot;
        encoding=&quot;UTF-8&quot;
        docencoding=&quot;UTF-8&quot;
        access=&quot;private&quot;&gt;
        &lt;doctitle&gt;${doc-title}&lt;/doctitle&gt;
        &lt;bottom&gt;${copyright}&lt;/bottom&gt;
        &lt;/javadoc&gt;
        &lt;echo&gt;on ${date} at ${time}&lt;/echo&gt;
        &lt;/target&gt;
        
        &lt;target name=&quot;zip&quot; depends=&quot;clean&quot; description=&quot;make zip file&quot;&gt;
        &lt;delete file=&quot;../${zipname}.zip&quot; /&gt;
        &lt;zip destfile=&quot;../${zipname}.zip&quot;&gt;
        &lt;zipfileset dir=&quot;.&quot; prefix=&quot;${zipname}&quot; /&gt;
        &lt;/zip&gt;
        &lt;echo&gt;on ${date} at ${time}&lt;/echo&gt;
        &lt;/target&gt;
        
        &lt;/project&gt;</pre>
<hr>
<div class="right-small">Copyright 2013 Project TreeLine, Updated: 2013/07/23 (Created: 2009/11/11)</div>
</body>
</html>
